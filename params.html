<!DOCTYPE html>
<html lang="en">
<head>
    <title>Dynamic Data Input Form with Distribution Types</title>
</head>
<body>
    <form id="dataForm"></form>
    <button type="submit" id="submitBtn">Submit</button>


    <script>
        // const formFields = [
        //     { id: "INEQUALITY", label: "Inequality", distribution: "fixed", val: 0.001, min: 0, max: 1, step: 0.0001 },
        //     { id: "RANSOM_B0", label: "Ransom B0", distribution: "fixed", val: 792145 },
        //     { id: "RANSOM_B1", label: "Ransom B1", distribution: "fixed", val: 0.00121 },
        //     { id: "RECOVERY_COST_BASE", label: "Recovery Cost Base", distribution: "fixed", val: 230123 },
        //     { id: "RECOVERY_COST_EXP", label: "Recovery Cost Exp", distribution: "fixed", val: 0.125 },
        //     { id: "WEALTH", label: "Wealth", distribution: "lognormal", mean: 1.1356082157016467, stddev: 1.1184432636889245 },
        //     { id: "POSTURE", label: "Posture", distribution: "truncated_normal", mean: 0.28, stddev: 0.10, min: 0.0, max: 1.0 },
        //     { id: "NUM_QUOTES", label: "Number of Quotes", distribution: "fixed", val: 10 }
        // ];
        const formFields = {
            "INEQUALITY" : {
                label: "INEQUALITY",
                default: {
                    distribution : "fixed",
                    val : 0.001,
                    min: 0,
                    max: 1,
                    mean: 0.001,
                    stddev: 0.0001
                },
                constraints: {
                    min: 0,
                    max: 1,
                    step: 0.0001
                }
            }
            
        }

        // Define the fields needed for each distribution type
        const distributionFields = {
            fixed: ['val'],
            // normal: ['mean', 'stddev'],
            lognormal: ['mean', 'stddev'],
            truncated_normal: ['mean', 'stddev', 'min', 'max'],
            uniform : ['min', 'max']

        };

        // Define the fields needed for each distribution type dynamically based on formFields
        const form = document.getElementById("dataForm");

        Object.keys(formFields).forEach(fieldId => {
            const field = formFields[fieldId];
            const fieldWrapper = document.createElement("div");
            fieldWrapper.id = `wrapper-${fieldId}`;
            form.appendChild(fieldWrapper);

            // Add a static header with the field's id name, only once
            const heading = document.createElement("h4");
            heading.textContent = `${fieldId}`;
            fieldWrapper.appendChild(heading);

            // Create and add the distribution dropdown
            const label = document.createElement("label");
            label.for = `${fieldId}-distribution`;
            label.textContent = `Distribution: `;
            fieldWrapper.appendChild(label);

            const select = document.createElement("select");
            select.id = `${fieldId}-distribution`;
            select.name = `${fieldId}-distribution`;

            // Create options for the dropdown based on available distributions
            ["fixed", "lognormal", "truncated_normal", "uniform"].forEach(dist => {
                const option = document.createElement("option");
                option.value = dist;
                option.textContent = dist;
                option.selected = dist === field.default.distribution; // Set selected value from default
                select.appendChild(option);
            });
            fieldWrapper.appendChild(select);

            // Create a container for dynamic fields below the dropdown
            const dynamicFieldsContainer = document.createElement("div");
            dynamicFieldsContainer.id = `dynamic-${fieldId}`;
            fieldWrapper.appendChild(dynamicFieldsContainer);

            // Create fields based on the default distribution type
            createDistributionFields(fieldId, field.default.distribution, field.default, dynamicFieldsContainer);

            // Update fields dynamically based on selected distribution
            select.addEventListener("change", function () {
                const selectedDist = select.value;
                createDistributionFields(fieldId, selectedDist, field.default, dynamicFieldsContainer);
            });
        });

        // Modify the createDistributionFields function to accept dynamicFieldsContainer as a parameter
        function createDistributionFields(fieldId, distribution, defaults, dynamicFieldsContainer) {
            dynamicFieldsContainer.innerHTML = ""; // Clear previous inputs

            // Create input fields based on the selected distribution type
            const fieldsToCreate = distributionFields[distribution] || [];

            
            
            fieldsToCreate.forEach(param => {
                const input = document.createElement("input");
                input.type = "number";
                input.name = `${fieldId}-${param}`;
                input.id = `${fieldId}-${param}`;
                input.value = defaults[param]; // Set default value or empty
                console.log(param, defaults[param]);

                // Create a tooltip element
                const tooltip = document.createElement("span");
                tooltip.className = "tooltip";
                tooltip.textContent = "";  // Text will be set if constraint is violated
                tooltip.style.visibility = "hidden";  // Hidden by default
                tooltip.style.color = "red";
                tooltip.style.fontSize = "12px";
                tooltip.style.marginLeft = "5px";

                // Append tooltip to the dynamic fields container
                dynamicFieldsContainer.appendChild(tooltip); // <-- Append the tooltip here

                const universalConstraints = formFields[fieldId].constraints;

                // Apply constraints if they exist
                if (universalConstraints) {
                    const { min, max, step } = universalConstraints;
                    if (min !== undefined) input.min = min;
                    if (max !== undefined) input.max = max;
                    if (step !== undefined) input.step = step;                    

                    // TODO add tighter min/max bounds for min max boxes?

                    input.addEventListener("click", function () {
                        console.log("click");

                        const minBox = document.getElementById(`${fieldId}-min`);
                        const maxBox = document.getElementById(`${fieldId}-max`);
                        const valMin = minBox ? parseFloat(minBox.value) : undefined;
                        const valMax = maxBox ? parseFloat(maxBox.value) : undefined;

                        if (param == "min") {
                            maxBox.min = (parseFloat(input.value) + parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                        } else if (param == "max") {
                            minBox.max = (parseFloat(input.value) - parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                        }
                        console.log("minBox bounds: ", minBox.min, minBox.max);
                        console.log("maxBox bounds: ", maxBox.min, maxBox.max);

                    });

                    input.addEventListener("input", function () {
                        console.log("input");

                        const minBox = document.getElementById(`${fieldId}-min`);
                        const maxBox = document.getElementById(`${fieldId}-max`);
                        const valMin = minBox ? parseFloat(minBox.value) : undefined;
                        const valMax = maxBox ? parseFloat(maxBox.value) : undefined;

                        if ( valMin != undefined && valMax != undefined  && valMin >= valMax ) {
                            console.log("min max violation");
                            tooltip.textContent = `min must be greater than max`;
                            tooltip.style.visibility = "visible"; // Show the tooltip
                        } else if (input.value < min || input.value > max) {
                            tooltip.textContent = `Value must be between ${min} and ${max}.`;
                            tooltip.style.visibility = "visible"; // Show the tooltip
                        }
                    });
                    
                    input.addEventListener("blur", function () {
                        console.log("blur");
                    });


                    // console.log(fieldId);

                    // Enforce constraints in real-time
                    // input.addEventListener("input", function () {
                    //     const value = parseFloat(input.value);

                    //     const dropdown = document.getElementById(`${fieldId}-distribution`);
                    //     const selectedValue = dropdown.options[dropdown.selectedIndex].value;



                    //     // if (ret = document.getElementById(`${fieldId}-min`));
                    //     // const valMax = parseFloat(document.getElementById(`${fieldId}-max`).value);
                    //     const minBox = document.getElementById(`${fieldId}-min`);
                    //     const maxBox = document.getElementById(`${fieldId}-max`);
                    //     const valMin = minBox ? parseFloat(minBox.value) : undefined;
                    //     const valMax = maxBox ? parseFloat(maxBox.value) : undefined;

                        


                    //     // console.log("Selected value:", selectedValue);
                    //     // console.log(`${fieldId}-min`);
                    //     console.log(valMin, valMax);

                    //     // if (isNaN(value)) {
                    //     //     input.value = defaults[param]; // Set default value or empty
                    //     // }
                    //     // if (!isNaN(value)) {
                    //         // If input value violates min/max, show tooltip and reset
                    //         if (value < min || value > max) {
                    //             tooltip.textContent = `Value must be between ${min} and ${max}.`;
                    //             tooltip.style.visibility = "visible"; // Show the tooltip
                    //             // if (param == "max") {
                    //             //     minBox.max = (parseFloat(input.value) - parseFloat(input.step));
                    //             // } else if (param == "min") {
                    //             //     maxBox.min = (parseFloat(input.value) + parseFloat(input.step));
                    //             // }
                    //         }
                    //         else if ( valMin != undefined && valMax != undefined  && valMin >= valMax ) {
                    //             console.log("min max violation");
                    //             tooltip.textContent = `min must be greater than max`;
                    //             tooltip.style.visibility = "visible"; // Show the tooltip

                    //             // if (param == "min") {
                    //             //     input.max = (valMax - parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //             // } else if (param == "max") {
                    //             //     input.min = (valMin +  parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //             // }
                    //             // minBox.max = (valMax - parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //             // maxBox.min = (valMin + parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //             // if (param == "min") {
                    //             //     // input.value = (valMax - parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //             //     // maxBox.min = (input.value).toFixed(input.step.toString().length - 2);
                    //             //     minBox.max = (valMax - parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //             //     maxBox.min = (input.value)
                    //             // } else if (param == "max") {
                    //             //     // input.value = (valMin +  parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //             //     // minBox.max = (input.value).toFixed(input.step.toString().length - 2);
                    //             //     maxBox.min = (valMin +  parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //             //     minBox.max = (input.value)
                    //             // }
                    //         }


                    //         // else if ( (selectedValue == "uniform" || selectedValue == "truncated_normal")) {
                    //         //     // console.log(param, value);
                    //         //     // console.log()
                    //         //     console.log("match");
                    //         // } 
                    //         // else {
                    //         //     tooltip.style.visibility = "hidden"; // Hide the tooltip
                    //         // }
                    //     // }

                    //     if ( param == "min" || param == "max" ) {

                    //     }

                    // });

                    // // Automatically adjust out-of-range values on blur
                    // input.addEventListener("blur", function () {
                    //     const value = parseFloat(input.value);

                    //     const dropdown = document.getElementById(`${fieldId}-distribution`);
                    //     const selectedValue = dropdown.options[dropdown.selectedIndex].value;

                    //     const minBox = document.getElementById(`${fieldId}-min`);
                    //     const maxBox = document.getElementById(`${fieldId}-max`);
                    //     const valMin = minBox ? parseFloat(minBox.value) : undefined;
                    //     const valMax = maxBox ? parseFloat(maxBox.value) : undefined;

                    //     if (isNaN(value)) {
                    //         input.value = defaults[param]; // Set default value or empty
                    //     }


                    //     if (value < input.min || value > input.max) {
                    //         input.value = Math.max(input.min, Math.min(value, input.max));
                    //         // minBox.max = (valMax - parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //         // maxBox.min = (valMin +  parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //         console.log("abs violations. new: ", input.value);
                    //         if (param == "max") {
                    //             minBox.max = (parseFloat(input.value) - parseFloat(input.step));
                    //         } else if (param == "min") {
                    //             maxBox.min = (parseFloat(input.value) + parseFloat(input.step));
                    //         }
                    //     }
                    //     if ( valMin != undefined && valMax != undefined  && valMin >= valMax ) {
                    //         if (param == "min") {
                    //             input.value = (valMax - parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //             minBox.max = input.value;
                    //             maxBox.min = (parseFloat(input.value) + parseFloat(input.step))

                    //             console.log("minBox.max: ", minBox.max);
                    //             console.log("maxBox.min: ", maxBox.min);
                    //         } else if (param == "max") {
                    //             input.value = (valMin +  parseFloat(input.step)).toFixed(input.step.toString().length - 2);
                    //             maxBox.min = input.value;
                    //             minBox.max = (parseFloat(input.value) - parseFloat(input.step))
                    //         }
                    //         // 
                    //         //
                    //     }
                    //     tooltip.style.visibility = "hidden"; // Hide tooltip if corrected
                    // });
                }

                const paramLabel = document.createElement("label");
                paramLabel.htmlFor = input.name; // Using name instead of id
                paramLabel.textContent = ` ${param}: `;

                dynamicFieldsContainer.appendChild(paramLabel);
                dynamicFieldsContainer.appendChild(input);
                dynamicFieldsContainer.appendChild(tooltip); // Append tooltip after the input
                dynamicFieldsContainer.appendChild(document.createElement("br"));
            });

        }




        // Collect form data and submit
        document.getElementById("submitBtn").addEventListener("click", function (e) {
            e.preventDefault();
            const formData = {};
            formFields.forEach(field => {
                const distribution = document.getElementById(`${field.id}-distribution`).value;
                formData[field.id] = { distribution };
                distributionFields[distribution].forEach(param => {
                    formData[field.id][param] = parseFloat(document.getElementById(`${field.id}-${param}`).value);
                });
            });

            fetch('process.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formData)
            })
            .then(response => response.json())
            .then(result => {
                const plotData = result.plotData;
                Plotly.newPlot('plotly-div', plotData);
            })
            .catch(error => console.error('Error:', error));
        });
    </script>
</body>
</html>
