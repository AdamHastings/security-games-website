<!DOCTYPE html>
<html lang="en">
<head>
    <title>Dynamic Data Input Form with Distribution Types</title>
</head>
<body>
    <h1>Inputs</h1>
    <form id="dataForm"></form>
    <br>
    <button type="submit" id="submitBtn"  onclick="document.getElementById('iframe-generated').src='process_input.php'">Submit</button>

    <h1>Results</h1>
    <!--  <button onclick="document.getElementById('iframe-generated').src='process_input.php'">Load Generated HTML</button> -->

    <!-- The iframe will display the generated HTML -->
    <iframe id="iframe-generated" style="width:800px; height:400px;"></iframe>


    <script>
        const formFields = {
            "INEQUALITY" : {
                default: {
                    distribution : "fixed",
                    val : 0.001,
                    min: 0,
                    max: 1,
                    mean: 0.001,
                    stddev: 0.0001
                },
                constraints: {
                    min: 0,
                    max: 1,
                    step: 0.0001,
                    allowed_dists: ["fixed", "lognormal", "normal", "truncated_normal", "uniform"]
                }
            },
            "RANSOM_B0" : {
                default: {
                    distribution : "fixed",
                    val : 792145,
                    min: 0,
                    max: 1000000000,
                    mean: 792145,
                    stddev: 792145
                },
                constraints: {
                    min: 0,
                    max: 1000000000,
                    step: 1,
                    allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]
                }
            },
            "RANSOM_B1" : {
                default: { distribution : "fixed", val : 0.00121, min: 0, max: 1, mean: 0.00121, stddev: 0.00121},
                constraints: { min: 0, max: 1, step: 0.00001, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "RECOVERY_COST_BASE" : {
                default: { distribution : "fixed", val : 230123, min: 0, max: 1000000000, mean: 230123, stddev: 230123},
                constraints: { min: 0, max: 1000000000, step: 1, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "RECOVERY_COST_EXP" : {
                default: { distribution : "fixed", val : 0.125, min: 0, max: 1, mean: 0.125, stddev: 0.125},
                constraints: { min: 0, max: 1, step: 0.001, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "WEALTH" : {
                default: { distribution : "lognormal", val : 3.113, min: 0, max: 10, mean: 3.113, stddev: 3.060},
                constraints: { min: 0, max: 10, step: 0.001, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "POSTURE" : {
                default: { distribution : "truncated_normal", val : 0.28, min: 0, max: 1, mean: 0.28, stddev: 0.10},
                constraints: { min: 0, max: 1, step: 0.01, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "POSTURE_NOISE" : {
                default: { distribution : "normal", val : 0, min: -1, max: 1, mean: 0, stddev: 0.10},
                constraints: { min: -1, max: 1, step: 0.01, allowed_dists: ["fixed", "lognormal", "normal", "truncated_normal", "uniform"]}
            },
            "NUM_QUOTES" : {
                default: { distribution : "truncated_normal", val : 10, min: 0, max: 100, mean: 10, stddev: 2},
                constraints: { min: 0, max: 100, step: 1, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "LOSS_RATIO" : {
                default: { distribution : "fixed", val : 0.80, min: 0, max: 1, mean: 0.80, stddev: 0.1},
                constraints: { min: 0, max: 1, step: 0.01, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "RETENTION_REGRESSION_FACTOR" : {
                default: { distribution : "fixed", val : 25, min: 0, max: 1000, mean: 25, stddev: 10},
                constraints: { min: 0, max: 1000, step: 1, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "NUM_DEFENDERS" : {
                default: { distribution : "fixed", val : 50, min: 0, max: 500, mean: 50, stddev: 10},
                constraints: { min: 0, max: 500, step: 1, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "NUM_INSURERS" : {
                default: { distribution : "fixed", val : 20, min: 0, max: 500, mean: 20, stddev: 10},
                constraints: { min: 0, max: 500, step: 1, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "NUM_ATTACKERS" : {
                default: { distribution : "fixed", val : 5, min: 0, max: 500, mean: 5, stddev: 2},
                constraints: { min: 0, max: 500, step: 1, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "ATTACKS_PER_EPOCH" : {
                default: { distribution : "fixed", val : 100, min: 0, max: 500, mean: 100, stddev: 10},
                constraints: { min: 0, max: 500, step: 1, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "CTA_SCALING_FACTOR" : {
                default: { distribution : "fixed", val : 0.857, min: 0, max: 10, mean: 0.857, stddev: 0.2},
                constraints: { min: 0, max: 10, step: 0.001, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "DEPRECIATION" : {
                default: { distribution : "fixed", val : 0.4, min: 0, max: 1, mean: 0.4, stddev: 0.1},
                constraints: { min: 0, max: 1, step: 0.01, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "TARGET_SECURITY_SPENDING" : {
                default: { distribution : "fixed", val : 0.01, min: 0, max: 1, mean:  0.01, stddev: 0.001},
                constraints: { min: 0, max: 1, step: 0.001, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "INVESTMENT_SCALING_FACTOR" : {
                default: { distribution : "fixed", val : 25, min: 0, max: 1000, mean:  25, stddev: 5},
                constraints: { min: 0, max: 1000, step: 1, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            "MANDATORY_INVESTMENT" : {
                default: { distribution : "fixed", val : 0, min: 0, max: 1, mean:  0, stddev: 0.001},
                constraints: { min: 0, max: 1, step: 0.001, allowed_dists: ["fixed", "lognormal", "truncated_normal", "uniform"]}
            },
            
            
        }

        // Define the fields needed for each distribution type
        const distributionFields = {
            fixed: ['val'],
            normal: ['mean', 'stddev'],
            lognormal: ['mean', 'stddev'],
            truncated_normal: ['mean', 'stddev', 'min', 'max'],
            uniform : ['min', 'max']

        };

        // Define the fields needed for each distribution type dynamically based on formFields
        const form = document.getElementById("dataForm");

        Object.keys(formFields).forEach(fieldId => {
            const field = formFields[fieldId];
            const fieldWrapper = document.createElement("div");
            fieldWrapper.id = `wrapper-${fieldId}`;
            form.appendChild(fieldWrapper);

            // Add a static header with the field's id name, only once
            const heading = document.createElement("h4");
            heading.textContent = `${fieldId}`;
            fieldWrapper.appendChild(heading);

            // Create and add the distribution dropdown
            const label = document.createElement("label");
            label.for = `${fieldId}-distribution`;
            label.textContent = `Distribution: `;
            fieldWrapper.appendChild(label);

            const select = document.createElement("select");
            select.id = `${fieldId}-distribution`;
            select.name = `${fieldId}-distribution`;

            // Create options for the dropdown based on available distributions
            formFields[fieldId].constraints.allowed_dists.forEach(dist => {
                const option = document.createElement("option");
                option.value = dist;
                option.textContent = dist;
                option.selected = dist === field.default.distribution; // Set selected value from default
                select.appendChild(option);
            });
            fieldWrapper.appendChild(select);

            // Create a container for dynamic fields below the dropdown
            const dynamicFieldsContainer = document.createElement("div");
            dynamicFieldsContainer.id = `dynamic-${fieldId}`;
            fieldWrapper.appendChild(dynamicFieldsContainer);

            // Create fields based on the default distribution type
            createDistributionFields(fieldId, field.default.distribution, field.default, dynamicFieldsContainer);

            // Update fields dynamically based on selected distribution
            select.addEventListener("change", function () {
                const selectedDist = select.value;
                createDistributionFields(fieldId, selectedDist, field.default, dynamicFieldsContainer);
            });
        });

        // Modify the createDistributionFields function to accept dynamicFieldsContainer as a parameter
        function createDistributionFields(fieldId, distribution, defaults, dynamicFieldsContainer) {
            dynamicFieldsContainer.innerHTML = ""; // Clear previous inputs

            // Create input fields based on the selected distribution type
            const fieldsToCreate = distributionFields[distribution] || [];


            // TODO make stddev > 0
            // TODO make lognormal defaults log of normal
            // TODO make mean between min and max
            // todo use mean instead of val
            
            
            fieldsToCreate.forEach(param => {
                const input = document.createElement("input");
                input.type = "number";
                input.name = `${fieldId}-${param}`;
                input.id = `${fieldId}-${param}`;
                input.value = defaults[param]; // Set default value or empty

                // Create a tooltip element
                const tooltip = document.createElement("span");
                tooltip.className = "tooltip";
                tooltip.textContent = "";  // Text will be set if constraint is violated
                tooltip.style.visibility = "hidden";  // Hidden by default
                tooltip.style.color = "red";
                tooltip.style.fontSize = "12px";
                tooltip.style.marginLeft = "5px";

                // Append tooltip to the dynamic fields container
                dynamicFieldsContainer.appendChild(tooltip); // <-- Append the tooltip here

                const universalConstraints = formFields[fieldId].constraints;

                // Apply constraints if they exist
                if (universalConstraints) {
                    const { min, max, step } = universalConstraints;
                    if (min !== undefined) input.min = min;
                    if (max !== undefined) input.max = max;
                    if (step !== undefined) input.step = step; 
                    
                    if (param == "min") input.max = (parseFloat(max) - parseFloat(input.step)).toFixed(Math.max(1, input.step.toString().length - 2));
                    if (param == "max") input.min = (parseFloat(min) + parseFloat(input.step)).toFixed(Math.max(1, input.step.toString().length - 2));


                    input.addEventListener("click", function () {
                        const minBox = document.getElementById(`${fieldId}-min`);
                        const maxBox = document.getElementById(`${fieldId}-max`);
                        const valMin = minBox ? parseFloat(minBox.value) : undefined;
                        const valMax = maxBox ? parseFloat(maxBox.value) : undefined;

                        if (param == "min") {
                            maxBox.min = (parseFloat(input.value) + parseFloat(input.step)).toFixed(Math.max(1, input.step.toString().length - 2));
                        } else if (param == "max") {
                            minBox.max = (parseFloat(input.value) - parseFloat(input.step)).toFixed(Math.max(1, input.step.toString().length - 2));
                        }

                    });

                    input.addEventListener("input", function () {
                        const minBox = document.getElementById(`${fieldId}-min`);
                        const maxBox = document.getElementById(`${fieldId}-max`);
                        const valMin = minBox ? parseFloat(minBox.value) : undefined;
                        const valMax = maxBox ? parseFloat(maxBox.value) : undefined;

                        if ( valMin != undefined && valMax != undefined  && valMin >= valMax ) {
                            tooltip.textContent = `max must be greater than min`;
                            tooltip.style.visibility = "visible"; // Show the tooltip
                        } else if (input.value < min || input.value > max) {
                            tooltip.textContent = `Value must be between ${min} and ${max}.`;
                            tooltip.style.visibility = "visible"; // Show the tooltip
                        }
                    });
                    
                    input.addEventListener("blur", function () {
                        const value = parseFloat(input.value);

                        const dropdown = document.getElementById(`${fieldId}-distribution`);
                        const selectedValue = dropdown.options[dropdown.selectedIndex].value;

                        const minBox = document.getElementById(`${fieldId}-min`);
                        const maxBox = document.getElementById(`${fieldId}-max`);
                        const valMin = minBox ? parseFloat(minBox.value) : undefined;
                        const valMax = maxBox ? parseFloat(maxBox.value) : undefined;

                        if (isNaN(value)) {
                            input.value = defaults[param]; // Set default value or empty
                        }
                        if (value < input.min ) {
                            input.value = input.min;
                        }
                        if (value > input.max) {
                            input.value = input.max;
                        }
                        if (valMin >= valMax) {
                            if (param == "min") {
                                input.value = minBox.max;
                            }
                            if (param == "max") {
                                input.value = maxBox.min;
                            }
                        }

                        if (param == "min") {
                            maxBox.min = (parseFloat(input.value) + parseFloat(input.step)).toFixed(Math.max(1, input.step.toString().length - 2));
                        } else if (param == "max") {
                            minBox.max = (parseFloat(input.value) - parseFloat(input.step)).toFixed(Math.max(1, input.step.toString().length - 2));
                        }

                        tooltip.style.visibility = "hidden"; // Hide tooltip if corrected
                    });

                }

                const paramLabel = document.createElement("label");
                paramLabel.htmlFor = input.name; // Using name instead of id
                paramLabel.textContent = ` ${param}: `;

                dynamicFieldsContainer.appendChild(paramLabel);
                dynamicFieldsContainer.appendChild(input);
                dynamicFieldsContainer.appendChild(tooltip); // Append tooltip after the input
                dynamicFieldsContainer.appendChild(document.createElement("br"));
            });

        }




        // Collect form data and submit
        document.getElementById("submitBtn").addEventListener("click", function (e) {
            e.preventDefault();
            const formData = {};
            formFields.forEach(field => {
                const distribution = document.getElementById(`${field.id}-distribution`).value;
                formData[field.id] = { distribution };
                distributionFields[distribution].forEach(param => {
                    formData[field.id][param] = parseFloat(document.getElementById(`${field.id}-${param}`).value);
                });
            });

            fetch('process_input.php', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(formData)
            })
            .then(response => response.json())
            .then(result => {
                const plotData = result.plotData;
                Plotly.newPlot('plotly-div', plotData);
            })
            .catch(error => console.error('Error:', error));
        });
    </script>
</body>
</html>
